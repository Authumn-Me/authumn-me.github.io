<!DOCTYPE html>
<html lang="en" dir="auto" data-theme="dark">

<head><script src="/livereload.js?mindelay=10&amp;v=2&amp;port=1313&amp;path=livereload" data-no-instant defer></script><meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<meta name="robots" content="noindex, nofollow">
<title>Kerberoasting: How Service Accounts Become a Silent Credential Exposure Risk | Authumn’s Notebook</title>
<meta name="keywords" content="windows, security, active directory, kerberos">
<meta name="description" content="Kerberos is the primary authentication mechanism in Active Directory environments and is designed to provide secure, ticket-based authentication between users, services and domain controllers. While Kerberos itself is a strong protocol, its security depends heavily on how service accounts are configured. One commonly overlooked weakness is Kerberoasting, a technique that allows attackers to extract service ticket hashes and perform offline password attacks against service accounts.
Kerberoasting does not exploit a vulnerability in Kerberos. Instead, it abuses legitimate protocol behaviour combined with weak or mismanaged service account credentials. This makes the technique particularly dangerous, as it often remains undetected and does not require elevated privileges.">
<meta name="author" content="">
<link rel="canonical" href="http://localhost:1313/blog/kerberoasting-how-service-accounts-become-a-silent-credential-exposure-risk/">
<link crossorigin="anonymous" href="/assets/css/stylesheet.12fe53f86c18b8f1b9022f785825d05a87575f72f414075af531dd655a9bba67.css" integrity="sha256-Ev5T&#43;GwYuPG5Ai94WCXQWodXX3L0FAda9THdZVqbumc=" rel="preload stylesheet" as="style">
<link rel="icon" href="http://localhost:1313/favicon.ico">
<link rel="icon" type="image/png" sizes="16x16" href="http://localhost:1313/favicon-16x16.png">
<link rel="icon" type="image/png" sizes="32x32" href="http://localhost:1313/favicon-32x32.png">
<link rel="apple-touch-icon" href="http://localhost:1313/apple-touch-icon.png">
<link rel="mask-icon" href="http://localhost:1313/safari-pinned-tab.svg">
<meta name="theme-color" content="#2e2e33">
<meta name="msapplication-TileColor" content="#2e2e33">
<link rel="alternate" hreflang="en" href="http://localhost:1313/blog/kerberoasting-how-service-accounts-become-a-silent-credential-exposure-risk/">
<noscript>
    <style>
        #theme-toggle,
        .top-link {
            display: none;
        }

    </style>
</noscript>
<script>
    if (localStorage.getItem("pref-theme") === "light") {
        document.querySelector("html").dataset.theme = 'light';
    }

</script>
</head>
<body id="top">
    <header class="header">
    <nav class="nav">
        <div class="logo">
            <a href="http://localhost:1313/" accesskey="h" title="Authumn’s Notebook (Alt + H)">
                <img src="http://localhost:1313/images/logo.png" alt="" aria-label="logo"
                    height="152">Authumn’s Notebook</a>
            <div class="logo-switches">
                <button id="theme-toggle" hidden=true accesskey="t" title="(Alt + T)" aria-label="Toggle theme" >
                    <svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <path d="M21 12.79A9 9 0 1 1 11.21 3 7 7 0 0 0 21 12.79z"></path>
                    </svg>
                    <svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <circle cx="12" cy="12" r="5"></circle>
                        <line x1="12" y1="1" x2="12" y2="3"></line>
                        <line x1="12" y1="21" x2="12" y2="23"></line>
                        <line x1="4.22" y1="4.22" x2="5.64" y2="5.64"></line>
                        <line x1="18.36" y1="18.36" x2="19.78" y2="19.78"></line>
                        <line x1="1" y1="12" x2="3" y2="12"></line>
                        <line x1="21" y1="12" x2="23" y2="12"></line>
                        <line x1="4.22" y1="19.78" x2="5.64" y2="18.36"></line>
                        <line x1="18.36" y1="5.64" x2="19.78" y2="4.22"></line>
                    </svg>
                </button>
            </div>
        </div>
        <ul id="menu">
            <li>
                <a href="http://localhost:1313/" title="whoami">
                    <span>whoami</span>
                </a>
            </li>
            <li>
                <a href="http://localhost:1313/blog" title="Blogs">
                    <span>Blogs</span>
                </a>
            </li>
            <li>
                <a href="http://localhost:1313/tags/" title="Tags">
                    <span>Tags</span>
                </a>
            </li>
        </ul>
    </nav>
</header>
<main class="main">

<article class="post-single">
  <header class="post-header">
    
    <h1 class="post-title entry-hint-parent">
      Kerberoasting: How Service Accounts Become a Silent Credential Exposure Risk
    </h1>
    <div class="post-meta"><span title='2025-12-28 00:00:00 +0000 UTC'>December 28, 2025</span>&nbsp;·&nbsp;<span>7 min</span>

</div>
  </header> 
  <div class="post-content"><p>Kerberos is the primary authentication mechanism in Active Directory environments and is designed to provide secure, ticket-based authentication between users, services and domain controllers. While Kerberos itself is a strong protocol, its security depends heavily on how service accounts are configured. One commonly overlooked weakness is Kerberoasting, a technique that allows attackers to extract service ticket hashes and perform offline password attacks against service accounts.</p>
<p>Kerberoasting does not exploit a vulnerability in Kerberos. Instead, it abuses legitimate protocol behaviour combined with weak or mismanaged service account credentials. This makes the technique particularly dangerous, as it often remains undetected and does not require elevated privileges.</p>
<h2 id="how-kerberoasting-works"><strong>How Kerberoasting works</strong><a hidden class="anchor" aria-hidden="true" href="#how-kerberoasting-works">#</a></h2>
<p>Kerberoasting abuses the way Kerberos handles authentication for services that run under domain accounts. In Active Directory, services that use Kerberos authentication are associated with a Service Principal Name, or SPN. This SPN links a specific service instance to a user or computer account and allows clients to request a Kerberos service ticket when they need to access that service.</p>
<p>When a domain user requests access to a Kerberos-enabled service, the domain controller issues a service ticket known as a Ticket Granting Service ticket. This ticket is encrypted using a key derived from the password of the service account that owns the SPN. The encryption ensures that only the intended service can decrypt and use the ticket.</p>
<p>The critical aspect is that any authenticated domain user is allowed to request service tickets for any SPN in the domain. This behaviour is by design and required for Kerberos to function correctly. However, it also means that a user does not need elevated privileges to obtain tickets for services they are not authorised to access.</p>
<p>Although the service ticket does not contain the service account password in plaintext, it contains cryptographic material that is directly tied to that password. Once a ticket has been obtained, it can be extracted and analysed offline. Because this analysis happens outside the Active Directory environment, it is not subject to account lockout policies, rate limiting or real-time detection controls.</p>
<p>If the service account password is weak then the encrypted portion of the ticket can be used to recover the original password through offline guessing techniques.</p>
<p>Kerberoasting therefore transforms service accounts into passive credential exposure points. The attack does not require exploitation of a vulnerability, interaction with the service itself or modification of directory objects. It relies entirely on legitimate Kerberos functionality combined with insufficient service account hygiene.</p>
<h2 id="observed-behaviour-during-analysis"><strong>Observed behaviour during analysis</strong><a hidden class="anchor" aria-hidden="true" href="#observed-behaviour-during-analysis">#</a></h2>
<p>The evidence below demonstrates the enumeration of all accounts within the domain that have one or more Service Principal Names configured. Service ticket requests were issued for these accounts, and the domain controller responded as expected by returning Kerberos service tickets for each associated service account. This behaviour is part of normal Kerberos operation and does not, by default, generate warnings or errors.</p>
<p>The returned tickets contain encrypted data derived from the passwords of the corresponding service accounts. Although the tickets do not expose plaintext credentials, they include cryptographic material that can be analysed offline. This process requires no interaction with the services themselves and does not involve any modification of directory objects.</p>
<p>The screenshot below shows how SPN-enabled accounts can be enumerated and how their associated service tickets can be retrieved using the GetUserSPNs functionality from the Impacket toolkit.</p>
<p><img loading="lazy" src="/blog/kerberoasting-how-service-accounts-become-a-silent-credential-exposure-risk/SPNAccounts.png"></p>
<p>Once the service tickets have been obtained, the encrypted ticket data can be extracted for further offline analysis. The following screenshot illustrates the extracted hashes derived from the captured service tickets.</p>
<p><img loading="lazy" src="/blog/kerberoasting-how-service-accounts-become-a-silent-credential-exposure-risk/Hashes.png"></p>
<p>These observations highlight that Kerberoasting activity blends seamlessly into legitimate domain behaviour. Service ticket requests are indistinguishable from normal Kerberos operations, making detection difficult without focused monitoring or anomaly-based analysis.</p>
<h2 id="impact-of-extracted-service-ticket-hashes"><strong>Impact of extracted service ticket hashes</strong><a hidden class="anchor" aria-hidden="true" href="#impact-of-extracted-service-ticket-hashes">#</a></h2>
<p>Once a service ticket hash has been obtained, it can be processed offline. Since this activity takes place entirely outside the Active Directory environment, account lockout policies, rate limiting and most monitoring controls do not apply. The likelihood of recovering the original password depends primarily on its complexity, reuse and how long it has remained unchanged.</p>
<p>The screenshot below demonstrates that a weak service account password can be recovered in a short amount of time once the corresponding service ticket hash has been extracted.</p>
<p><img loading="lazy" src="/blog/kerberoasting-how-service-accounts-become-a-silent-credential-exposure-risk/Hashcat.png"></p>
<p>A compromised service account can have a significant impact on the environment. Service accounts often run critical applications, scheduled tasks or backend services and are frequently granted elevated privileges to function correctly. In practice, these privileges are often broader than necessary. In some environments, service accounts are members of highly privileged groups or even assigned Domain Administrator rights, dramatically increasing the blast radius of a successful Kerberoasting attack.</p>
<p>This combination of offline password exposure and excessive privileges makes poorly managed service accounts a high-value target within Active Directory environments.</p>
<h2 id="service-principal-names-as-the-root-cause"><strong>Service Principal Names as the root cause</strong><a hidden class="anchor" aria-hidden="true" href="#service-principal-names-as-the-root-cause">#</a></h2>
<p>Kerberoasting is only possible when a service account has an SPN assigned. SPNs bind a service instance to an account and enable Kerberos authentication for that service.</p>
<p>This screenshot below  the configration of a service account with an SPN confshowsigured, making it eligible for Kerberos service ticket requests.</p>
<p><img loading="lazy" src="/blog/kerberoasting-how-service-accounts-become-a-silent-credential-exposure-risk/SPN-Setup.png"></p>
<p>While SPNs are required for Kerberos to function correctly, they also define the attack surface for Kerberoasting. Poorly managed SPNs combined with weak passwords create a predictable exposure point.</p>
<h2 id="why-kerberoasting-is-difficult-to-detect"><strong>Why Kerberoasting is difficult to detect</strong><a hidden class="anchor" aria-hidden="true" href="#why-kerberoasting-is-difficult-to-detect">#</a></h2>
<p>Kerberoasting uses legitimate Kerberos functionality. Ticket requests are normal domain operations and do not generate obvious security alerts. The offline password recovery phase happens entirely outside the domain and leaves no trace in authentication logs.</p>
<p>Several factors contribute to its effectiveness:</p>
<ul>
<li>Any authenticated domain user can request service tickets</li>
<li>No interaction with the service itself is required</li>
<li>Offline cracking bypasses domain protections</li>
<li>Service account passwords often remain unchanged for long periods.</li>
</ul>
<p>As a result, Kerberoasting frequently remains unnoticed until after service accounts have already been compromised.</p>
<h2 id="mitigation-strategies"><strong>Mitigation strategies</strong><a hidden class="anchor" aria-hidden="true" href="#mitigation-strategies">#</a></h2>
<p>Reducing the risk of Kerberoasting does not require changes to the Kerberos protocol itself. Instead, effective mitigation focuses on improving service account hygiene and enforcing stricter identity management practices.</p>
<p><strong>Use strong, long and unique service account passwords</strong></p>
<p>Service accounts should be configured with passwords that are resistant to offline password guessing attacks. Weak, reused or predictable passwords significantly increase the likelihood of successful Kerberoasting once a service ticket hash has been extracted.</p>
<p><strong>Prefer managed service accounts</strong></p>
<p>Group Managed Service Accounts (gMSA) provide a robust solution by automatically generating and rotating strong passwords. By eliminating static credentials altogether, gMSAs effectively neutralise the primary weakness exploited by Kerberoasting.</p>
<p><strong>Limit service account privileges</strong></p>
<p>Service accounts should strictly adhere to the principle of least privilege. Only the permissions required for the service to function should be granted. Unnecessary domain-level or administrative rights significantly increase the impact of a compromised service account and should be avoided.</p>
<p><strong>Monitor service ticket request patterns</strong></p>
<p>Kerberoasting activity may appear as an unusual number of service ticket requests within a short time frame. Monitoring for abnormal Kerberos service ticket activity can help identify potential abuse and trigger further investigation.</p>
<p><strong>Audit and manage SPN assignments</strong></p>
<p>Service Principal Names should be reviewed regularly to ensure they are still required and correctly assigned. Removing unused or unnecessary SPNs reduces the number of accounts exposed to Kerberoasting and limits the overall attack surface.</p>
<h2 id="conclusion"><strong>Conclusion</strong><a hidden class="anchor" aria-hidden="true" href="#conclusion">#</a></h2>
<p>Kerberoasting shows a risk that exists in many Active Directory environments, not because Kerberos or Service Principal Names are insecure by design, but because service accounts are often poorly managed. SPNs are a normal and required part of Kerberos authentication and are needed for many services to operate correctly. This article does not suggest that SPNs should be removed.</p>
<p>The problem starts when SPNs are combined with weak, static or rarely changed service account passwords. In that situation, normal Kerberos behaviour can be abused to extract service ticket data and perform offline password cracking. This activity does not generate errors, does not require interaction with the service itself and is difficult to detect, as it looks like regular domain traffic.</p>
<p>The evidence in this article shows how quickly weak service account passwords can be recovered once a service ticket hash has been obtained. When these service accounts also have excessive privileges, the impact increases significantly and can, in some cases, lead to full domain compromise.</p>
<p>The goal of this article is to increase awareness of the risks associated with weak configured service account passwords. Kerberoasting is not about misusing SPNs, but about understanding how weak credentials turn a necessary feature into a security issue. By using strong passwords, limiting privileges and adopting managed service accounts, organisations can use Kerberos safely while greatly reducing the risk of Kerberoasting.</p>


  </div>

  <footer class="post-footer">
    <ul class="post-tags">
      <li><a href="http://localhost:1313/tags/windows/">Windows</a></li>
      <li><a href="http://localhost:1313/tags/security/">Security</a></li>
      <li><a href="http://localhost:1313/tags/active-directory/">Active Directory</a></li>
      <li><a href="http://localhost:1313/tags/kerberos/">Kerberos</a></li>
    </ul>
<nav class="paginav">
  <a class="prev" href="http://localhost:1313/blog/as-rep-roasting-exploiting-kerberos-pre-authentication-misconfigurations/">
    <span class="title">« Prev</span>
    <br>
    <span>AS-REP Roasting: Exploiting Kerberos Pre-Authentication Misconfigurations</span>
  </a>
  <a class="next" href="http://localhost:1313/blog/ldap-signing-and-ldaps-channel-binding-eliminating-a-key-path-to-domain-manipulation/">
    <span class="title">Next »</span>
    <br>
    <span>LDAP Signing and LDAPS Channel Binding: Eliminating a Key Path to Domain Manipulation</span>
  </a>
</nav>

  </footer>
</article>
    </main>
    
<footer class="footer">
        <span>&copy; 2026 <a href="http://localhost:1313/">Authumn’s Notebook</a></span> · 

    <span>
        Powered by
        <a href="https://gohugo.io/" rel="noopener noreferrer" target="_blank">Hugo</a> &
        <a href="https://github.com/adityatelange/hugo-PaperMod/" rel="noopener" target="_blank">PaperMod</a>
    </span>
</footer>
<a href="#top" aria-label="go to top" title="Go to Top (Alt + G)" class="top-link" id="top-link" accesskey="g">
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentColor">
        <path d="M12 6H0l6-6z" />
    </svg>
</a><script src="https://unpkg.com/medium-zoom@1.0.8/dist/medium-zoom.min.js"></script>
<script>
  mediumZoom('.post-content img', {
    margin: 24,
    background: '#000'
  })
</script>


<script>
    let menu = document.getElementById('menu');
    if (menu) {
        
        const scrollPosition = localStorage.getItem("menu-scroll-position");
        if (scrollPosition) {
            menu.scrollLeft = parseInt(scrollPosition, 10);
        }
        
        menu.onscroll = function () {
            localStorage.setItem("menu-scroll-position", menu.scrollLeft);
        }
    }

    document.querySelectorAll('a[href^="#"]').forEach(anchor => {
        anchor.addEventListener("click", function (e) {
            e.preventDefault();
            var id = this.getAttribute("href").substr(1);
            if (!window.matchMedia('(prefers-reduced-motion: reduce)').matches) {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView({
                    behavior: "smooth"
                });
            } else {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView();
            }
            if (id === "top") {
                history.replaceState(null, null, " ");
            } else {
                history.pushState(null, null, `#${id}`);
            }
        });
    });

</script>
<script>
    var mybutton = document.getElementById("top-link");
    window.onscroll = function () {
        if (document.body.scrollTop > 800 || document.documentElement.scrollTop > 800) {
            mybutton.style.visibility = "visible";
            mybutton.style.opacity = "1";
        } else {
            mybutton.style.visibility = "hidden";
            mybutton.style.opacity = "0";
        }
    };

</script>
<script>
    document.getElementById("theme-toggle").addEventListener("click", () => {
        const html = document.querySelector("html");
        if (html.dataset.theme === "dark") {
            html.dataset.theme = 'light';
            localStorage.setItem("pref-theme", 'light');
        } else {
            html.dataset.theme = 'dark';
            localStorage.setItem("pref-theme", 'dark');
        }
    })

</script>
<script>
    document.querySelectorAll('pre > code').forEach((codeblock) => {
        const container = codeblock.parentNode.parentNode;

        const copybutton = document.createElement('button');
        copybutton.classList.add('copy-code');
        copybutton.innerHTML = 'copy';

        function copyingDone() {
            copybutton.innerHTML = 'copied!';
            setTimeout(() => {
                copybutton.innerHTML = 'copy';
            }, 2000);
        }

        copybutton.addEventListener('click', (cb) => {
            if ('clipboard' in navigator) {
                navigator.clipboard.writeText(codeblock.textContent);
                copyingDone();
                return;
            }

            const range = document.createRange();
            range.selectNodeContents(codeblock);
            const selection = window.getSelection();
            selection.removeAllRanges();
            selection.addRange(range);
            try {
                document.execCommand('copy');
                copyingDone();
            } catch (e) { };
            selection.removeRange(range);
        });

        if (container.classList.contains("highlight")) {
            container.appendChild(copybutton);
        } else if (container.parentNode.firstChild == container) {
            
        } else if (codeblock.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName == "TABLE") {
            
            codeblock.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(copybutton);
        } else {
            
            codeblock.parentNode.appendChild(copybutton);
        }
    });
</script>
</body>

</html>
